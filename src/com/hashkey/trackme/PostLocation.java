package com.hashkey.trackme;

import java.io.IOException;
import java.util.List;
import java.util.Locale;

import android.app.Service;
import android.content.Intent;
import android.content.SharedPreferences;
import android.location.Address;
import android.location.Geocoder;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.net.ParseException;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.preference.PreferenceManager;
import android.telephony.SmsManager;
import android.util.Log;
import android.widget.Toast;

import com.parse.Parse;
import com.parse.ParseGeoPoint;
import com.parse.ParseObject;
import com.parse.ParseUser;

public class PostLocation extends Service implements LocationListener{
	
	private LocationManager locationManager;
	boolean canGetLocation = false;
	Location location;
	Handler handler = null;
	int count = 0;
	public SharedPreferences pref = null;
	Integer interval = null;
	private SMSRunnable r = null;
	private Integer delay = 0;
	public static ParseUser currentUser = null;
	private String phoneNo = null; 
	
    @Override
    public void onCreate() {
    	Log.d("MINE","Service OnCreate");
    	if(DispatchActivity.currentUser == null){
    		Log.d("MINE","currentUser is Null");
    		Parse.enableLocalDatastore(this);
    		Parse.initialize(this, "TrRahQfX0V4ohVGjSsVWcXwtExQnmofyHnLDAPUm", "LO65dGPtVDZzmRNa87udTW8vL0XIU54SR6uZahlw");
    	}
    	pref = PreferenceManager.getDefaultSharedPreferences(this);
    	interval = pref.getInt("smsInterval", 10)*60000;
    	currentUser = ParseUser.getCurrentUser();
    }
    
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
//    	Log.d("MINE","Service OnStart");
    	// meaning that an activity has called the service
    	handler = new Handler();
    	r = new SMSRunnable();
    	if (intent!=null){
    		delay = (Integer) intent.getExtras().get("delay")*10;//in milliseconds
    		handler.removeCallbacks(r);
    		handler.postDelayed(r, delay);
    		Log.d("MINE","Activity call!");
    	}else{
    		Toast.makeText(getBaseContext(), "Looks like the TrackMe is closed! Unexpected results might occur!", Toast.LENGTH_LONG).show();
    	}
    	
    	if (intent!= null) { //initiated by an activity
    		phoneNo = intent.getStringExtra("phoneNumber"); //if put, get the number to send
    		if(phoneNo!=null) Log.d("MINE","Phone: "+phoneNo); //show the number
    		else Log.d("MINE","No phone supplied!"); // if not put, or failed to send
    	}
    	//avoid duplicate call
//    	if(count!=0){
//    		Toast.makeText(getBaseContext(), "Already attempting the distress call...", Toast.LENGTH_SHORT).show();
//    		return START_STICKY;
//    	}
//    	r.run();
//    	count ++;//status making sure the thread won't run again.
    	return START_STICKY;
    }
    
    @Override
    public void onDestroy(){
    	Toast.makeText(getApplicationContext(), "Good to see everything fine!", Toast.LENGTH_SHORT).show();
    	r.stop = true;
    	super.onDestroy();
    }
    
    public class SMSRunnable implements Runnable {
        public boolean stop = false;
        @Override
        public void run() {
        	Log.d("MINE","posted");
        	if(stop) return;
    		handler.postDelayed(this, interval);
    		doIt();
        }
    }
    
    
    private void doIt(){
		location = getLocation();
		if (location == null){
			Toast.makeText(getApplicationContext(), "Can't get location. Are location services enabled?", Toast.LENGTH_LONG).show();
			return;
		}
		Geocoder geocoder = new Geocoder(getApplicationContext(), Locale.getDefault());
		Double lat = Double.valueOf(location.getLatitude());
		Double lng = Double.valueOf(location.getLongitude());
		String city = "stated above as (lat, long)";
		try {
			List<Address> addresses  = geocoder.getFromLocation(lat,lng, 1);
			city = addresses.get(0).getLocality();
		} catch (IOException e) {
			e.printStackTrace();
		}
	
	    if (phoneNo == null) phoneNo = currentUser.getString("emergencyContact");
		String message = new String("#TrackMe#\nEMERGENCY:\n"+lat.toString()+", "+lng.toString()+"\n"+currentUser.getString("firstName")+" seems to be in trouble."+
				" Last known location: "+city+". This message was auto-generated by 'TrackMe'");
		try {
			SmsManager smsManager = SmsManager.getDefault();
			smsManager.sendTextMessage(phoneNo, null, message, null, null);
			Toast.makeText(getApplicationContext(), "Sent Distress", Toast.LENGTH_LONG).show();
		} catch (Exception e) {
			Toast.makeText(getApplicationContext(), "SMS faild, please try again.", Toast.LENGTH_LONG).show();
			e.printStackTrace();
		}
		
		try{
			ParseObject locationData = new ParseObject("LocationData");
			ParseGeoPoint point = new ParseGeoPoint(lat,lng);
			Log.d("MINE","objID: "+currentUser.getString("username"));
			locationData.put("userId", currentUser.getString("username"));
			locationData.put("location", point);
			locationData.saveInBackground();
		}catch(ParseException e){
			Log.d("MINE","Exception Raised!");
		}
		 
		
    }
    
    public Location getLocation() {
		int MIN_TIME_BW_UPDATES = 2000;
		int MIN_DISTANCE_CHANGE_FOR_UPDATES = 0;
		
		
	    try {
	        locationManager = (LocationManager) this
	                .getSystemService(LOCATION_SERVICE);

	        // getting GPS status
	        boolean isGPSEnabled = locationManager
	                .isProviderEnabled(LocationManager.GPS_PROVIDER);

	        // getting network status
	        boolean isNetworkEnabled = locationManager
	                .isProviderEnabled(LocationManager.NETWORK_PROVIDER);

	        
	        if (!isGPSEnabled && !isNetworkEnabled) {
	            // no network provider is enabled
	        } else {
	            this.canGetLocation = true;
	            if (isNetworkEnabled) {
	                locationManager.requestLocationUpdates(
	                        LocationManager.NETWORK_PROVIDER,
	                        MIN_TIME_BW_UPDATES,
	                        MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
	                Log.d("Network", "Network Enabled");
	                if (locationManager != null) {
	                    location = locationManager
	                            .getLastKnownLocation(LocationManager.NETWORK_PROVIDER);
	                }
	            }
	            // if GPS Enabled get lat/long using GPS Services
	            if (isGPSEnabled) {
	                if (location == null) {
	                    locationManager.requestLocationUpdates(
	                            LocationManager.GPS_PROVIDER,
	                            MIN_TIME_BW_UPDATES,
	                            MIN_DISTANCE_CHANGE_FOR_UPDATES, this);
	                    Log.d("GPS", "GPS Enabled");
	                    if (locationManager != null) {
	                        location = locationManager
	                                .getLastKnownLocation(LocationManager.GPS_PROVIDER);
	                    }
	                }
	            }
	        }

	    } catch (Exception e) {
	        e.printStackTrace();
	    }

	    return location;
	}
    
    
	@Override
	public IBinder onBind(Intent intent) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void onLocationChanged(Location arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onProviderDisabled(String arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onProviderEnabled(String arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void onStatusChanged(String arg0, int arg1, Bundle arg2) {
		// TODO Auto-generated method stub
		
	}
}
